## Кастомный пул потоков

### Что реализовано

Реализован собственный пул потоков без использования `ThreadPoolExecutor`. Основные особенности:

* Возможность задавать параметры: минимальное и максимальное число потоков, таймаут бездействия, размер очереди задач и резерв потоков;
* Управление отказами при перегрузке;
* Подробное логирование всех событий;
* Интерфейс, совместимый с `Executor` и `CompletableFuture`.

### Настраиваемые параметры

* `corePoolSize` — минимальное количество потоков, которые пул должен поддерживать постоянно;
* `maxPoolSize` — верхний предел количества потоков;
* `keepAliveTime` и `timeUnit` — сколько времени поток может бездействовать до завершения;
* `queueSize` — ограничение на размер очереди задач;
* `minSpareThreads` — минимальное количество свободных (резервных) потоков, которые всегда должны быть доступны.

### Распределение задач

Используется одна общая очередь задач. При переполнении очереди:

1. Если ещё не достигнут `maxPoolSize`, создаётся новый поток;
2. Если достигнут — срабатывает `RejectedExecutionHandler`, который по умолчанию просто логирует отказ.

Алгоритм балансировки между несколькими очередями не реализован, но структура допускает его добавление.

### Поведение рабочих потоков (Worker)

Каждый поток:

* Берёт задачи из очереди и выполняет их;
* Если задач нет, ждёт до `keepAliveTime`;
* Если остаётся без работы дольше указанного времени и общее число потоков превышает `corePoolSize`, поток завершает работу;
* При завершении поток удаляется из пула и логируется.

Поток может быть прерван вручную через `shutdown()` или `shutdownNow()`.

### Обработка отказов

Реализован собственный `RejectedExecutionHandler`, который просто выводит сообщение в консоль. При необходимости можно заменить его на более сложную логику: например, немедленное выполнение задачи в текущем потоке или повторную попытку позже.

### Логирование

Пул логирует все ключевые события:

* Создание и завершение потоков;
* Принятие задач в очередь;
* Выполнение задач;
* Простой потока и его остановку;
* Отказы при переполнении очереди.

Это позволяет видеть поведение пула и оперативно находить узкие места.

### Демонстрация

В классе `Main` пул инициализируется с параметрами:

* `corePoolSize = 2`
* `maxPoolSize = 4`
* `queueSize = 5`
* `keepAliveTime = 5 секунд`
* `minSpareThreads = 1`

Запускается 10 задач, каждая из которых "спит" 3 секунды. Демонстрируются ситуации с добавлением задач в очередь, запуском дополнительных потоков и отказами при перегрузке. После завершения задач вызывается `shutdown()` и завершается программа.

### Анализ

Производительность пула сравнивалась со стандартным `ThreadPoolExecutor`. При небольшом количестве задач и высокой конкуренции поведение схожее. Разница становится заметна при перегрузке: собственный пул позволяет гибко задавать поведение при отказах и наличие "резервных" потоков, что может быть полезно в сервисах, где важно не упустить ни одной задачи.

Параметры `minSpareThreads` и `keepAliveTime` дают возможность тонкой настройки. Например, снижение `keepAliveTime` позволяет быстрее освобождать ресурсы, а увеличение `minSpareThreads` — повысить готовность к пиковым нагрузкам.
